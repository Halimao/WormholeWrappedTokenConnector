{"version":3,"file":"static/js/8416.5923f2a4.chunk.js","mappings":"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","sources":["../node_modules/@wormhole-foundation/wormhole-connect/lib/platform-BVScq6Cn.mjs","../node_modules/@wormhole-foundation/wormhole-connect/lib/aptos-DjCb_S8U.mjs","../node_modules/@wormhole-foundation/wormhole-connect/lib/chain-uXEmLNMk.mjs"],"sourcesContent":["var g = Object.defineProperty;\nvar m = (c, t, a) => t in c ? g(c, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : c[t] = a;\nvar l = (c, t, a) => m(c, typeof t != \"symbol\" ? t + \"\" : t, a);\nimport { e as f, u as w, W as C } from \"./chunk-KJH4KKG6-CCerRpgp.mjs\";\nimport { bE as y, W as _, a5 as b, j as u, bG as T, bH as N } from \"./address-BkeBsCZD.mjs\";\nimport { C as v, P as I } from \"./chain-uXEmLNMk.mjs\";\nimport { _ as k, a as h } from \"./address-xvE59bSC.mjs\";\nclass x extends v {\n}\nconst o = class o extends I {\n  constructor(t, a) {\n    super(t, a ?? y(t, o._platform));\n  }\n  getRpc(t) {\n    if (t in this.config) {\n      const a = this.network === \"Mainnet\" ? f.MAINNET : f.TESTNET, n = new w({ fullnode: this.config[t].rpc, network: a });\n      return new C(n);\n    }\n    throw new Error(\"No configuration available for chain: \" + t);\n  }\n  getChain(t, a) {\n    if (t in this.config)\n      return new x(t, this);\n    throw new Error(\"No configuration available for chain: \" + t);\n  }\n  static nativeTokenId(t, a) {\n    if (!this.isSupportedChain(a))\n      throw new Error(`invalid chain: ${a}`);\n    return _.tokenId(a, h);\n  }\n  static isNativeTokenId(t, a, n) {\n    return !this.isSupportedChain(a) || n.chain !== a ? !1 : this.nativeTokenId(t, a) == n;\n  }\n  static isSupportedChain(t) {\n    return b(t) === o._platform;\n  }\n  static async getDecimals(t, a, n) {\n    if (u(n) || n === h)\n      return T(o._platform);\n    const e = n.toString();\n    return (await a.getFungibleAssetMetadataByAssetType({ assetType: e })).decimals;\n  }\n  static async getBalance(t, a, n, e) {\n    var r;\n    const i = u(e) ? h : e.toString();\n    try {\n      return ((r = (await a.getCurrentFungibleAssetBalances({\n        options: {\n          where: {\n            owner_address: { _eq: n },\n            asset_type: { _eq: i }\n          }\n        }\n      }))[0]) == null ? void 0 : r.amount) ?? null;\n    } catch (s) {\n      if (s.status === 404)\n        return null;\n      throw s;\n    }\n  }\n  static async getBalances(t, a, n, e) {\n    try {\n      const i = await a.getCurrentFungibleAssetBalances({\n        options: {\n          where: {\n            owner_address: { _eq: n }\n          }\n        }\n      });\n      let r = {};\n      for (const s of i)\n        if (s.asset_type) {\n          let d = s.asset_type === \"0x1::aptos_coin::AptosCoin\" ? \"native\" : s.asset_type;\n          r[d] = s.amount;\n        }\n      return r;\n    } catch (i) {\n      if (i.status === 404)\n        return {};\n      throw i;\n    }\n  }\n  static async sendWait(t, a, n) {\n    const e = [];\n    for (const i of n) {\n      const r = await a.transaction.submit.simple(i.transaction), s = await a.waitForTransaction({\n        transactionHash: r.hash\n      });\n      e.push(s.hash);\n    }\n    return e;\n  }\n  static async getLatestBlock(t) {\n    const a = await t.getLedgerInfo();\n    return Number(a.block_height);\n  }\n  static async getLatestFinalizedBlock(t) {\n    const a = await t.getLedgerInfo();\n    return Number(a.block_height);\n  }\n  static chainFromChainId(t) {\n    const a = N(o._platform, BigInt(t));\n    if (!a)\n      throw new Error(`No matching chainId to determine network and chain: ${t}`);\n    const [n, e] = a;\n    return [n, e];\n  }\n  static async chainFromRpc(t) {\n    const a = await t.getLedgerInfo();\n    return this.chainFromChainId(a.chain_id.toString());\n  }\n};\nl(o, \"_platform\", k);\nlet p = o;\nexport {\n  p as A,\n  x as a\n};\n","var d = Object.defineProperty;\nvar p = (n, t, s) => t in n ? d(n, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : n[t] = s;\nvar r = (n, t, s) => p(n, typeof t != \"symbol\" ? t + \"\" : t, s);\nimport { A as o, a as u } from \"./platform-BVScq6Cn.mjs\";\nimport { z as g, a as m } from \"./chunk-KJH4KKG6-CCerRpgp.mjs\";\nimport { a3 as _, bD as f } from \"./address-BkeBsCZD.mjs\";\nimport { A as l, _ as A } from \"./address-xvE59bSC.mjs\";\nasync function S(n, t) {\n  const [s, i] = await o.chainFromRpc(n), a = g.fromPrivateKey({\n    // TODO: support secp256k1\n    privateKey: new m(_.decode(t))\n  });\n  return new w(i, a, n);\n}\nclass w {\n  constructor(t, s, i, a) {\n    r(this, \"_chain\");\n    r(this, \"_account\");\n    r(this, \"_rpc\");\n    r(this, \"_debug\");\n    this._chain = t, this._account = s, this._rpc = i, this._debug = a;\n  }\n  chain() {\n    return this._chain;\n  }\n  address() {\n    return this._account.accountAddress.toString();\n  }\n  async signAndSend(t) {\n    const s = [];\n    for (const i of t) {\n      const { description: a, transaction: c } = i;\n      this._debug && console.log(`Signing: ${a} for ${this.address()}`);\n      const e = await this._rpc.transaction.build.simple({\n        sender: this._account.accountAddress,\n        data: c\n      }), { hash: h } = await this._simSignSend(e);\n      s.push(h);\n    }\n    return s;\n  }\n  async _simSignSend(t) {\n    return await this._rpc.transaction.simulate.simple({\n      signerPublicKey: this._account.publicKey,\n      transaction: t\n    }).then((s) => s.forEach((i) => {\n      if (!i.success)\n        throw new Error(`Transaction failed: ${i.vm_status}\n${JSON.stringify(i, null, 2)}`);\n    })), this._rpc.signAndSubmitTransaction({ signer: this._account, transaction: t }).then((s) => this._rpc.waitForTransaction({ transactionHash: s.hash }));\n  }\n}\nconst P = {\n  Address: l,\n  Platform: o,\n  getSigner: S,\n  protocols: {\n    WormholeCore: () => import(\"./index-Naa9NLXw.mjs\"),\n    TokenBridge: () => import(\"./index-XkPtmd0r.mjs\"),\n    CircleBridge: () => import(\"./index-D1vSocUD.mjs\")\n  },\n  getChain: (n, t, s) => new u(t, new o(n, f(n, A, {\n    [t]: s\n  })))\n};\nexport {\n  P as default\n};\n","var l = Object.defineProperty;\nvar u = (r, t, i) => t in r ? l(r, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : r[t] = i;\nvar o = (r, t, i) => u(r, typeof t != \"symbol\" ? t + \"\" : t, i);\nimport { a6 as d, a5 as f, j as B, q as m, c8 as w, a7 as P } from \"./address-BkeBsCZD.mjs\";\nfunction k(r) {\n  return \"getVersion\" in r;\n}\nconst s = {};\nfunction R(r, t, i) {\n  t in s || (s[t] = {});\n  const e = s[t];\n  if (r in e)\n    throw new Error(`Protocol ${r} for protocol ${t} has already registered`);\n  s[t][r] = i;\n}\nfunction T(r, t) {\n  const i = d(r) ? f.get(r) : r;\n  return t in s ? i in s[t] : !1;\n}\nfunction g(r, t) {\n  if (t in s) {\n    const i = s[t];\n    if (i && r in i) {\n      const e = i[r];\n      if (e)\n        return e;\n    }\n  }\n  throw new Error(`No protocols registered for ${r}:${t}. This may be because the platform specific protocol implementation is not registered (by installing and importing it) or no implementation exists for this platform`);\n}\nconst C = (r, t, i, e) => g(r, t).fromRpc(i, e);\nclass W {\n  constructor(t, i) {\n    o(this, \"network\");\n    o(this, \"config\");\n    this.network = t, this.config = i;\n  }\n  /** provides access to the static attributes of the PlatformContext class */\n  utils() {\n    return this.constructor;\n  }\n  /** Create a new Protocol Client instance by protocol name using the RPC connection to determine the network */\n  getProtocol(t, i) {\n    return C(this.utils()._platform, t, i, this.config);\n  }\n  /** Get the underlying ProtocolInitializer to construct yourself */\n  getProtocolInitializer(t) {\n    return g(this.utils()._platform, t);\n  }\n  /** Look up transaction logs and parse out Wormhole messages */\n  async parseWormholeMessages(t, i, e) {\n    return (await this.getProtocol(\"WormholeCore\", i)).parseTransaction(e);\n  }\n}\nclass I {\n  constructor(t, i, e) {\n    o(this, \"network\");\n    o(this, \"chain\");\n    o(this, \"config\");\n    o(this, \"platform\");\n    o(this, \"rpc\");\n    // Cached Protocol clients\n    o(this, \"protocols\", /* @__PURE__ */ new Map());\n    /**\n     * Check to see if the Wormhole Core protocol is supported by this chain\n     * @returns a boolean indicating if this chain supports the Wormhole Core protocol\n     */\n    o(this, \"supportsWormholeCore\", () => this.supportsProtocol(\"WormholeCore\"));\n    /**\n     * Get the Wormhole Core protocol client for this chain\n     * @returns the Wormhole Core protocol client for this chain\n     */\n    o(this, \"getWormholeCore\", () => this.getProtocol(\"WormholeCore\"));\n    /**\n     * Check to see if the Token Bridge protocol is supported by this chain\n     * @returns a boolean indicating if this chain supports the Token Bridge protocol\n     */\n    o(this, \"supportsTokenBridge\", () => this.supportsProtocol(\"TokenBridge\"));\n    /**\n     * Get the Token Bridge protocol client for this chain\n     * @returns the Token Bridge protocol client for this chain\n     */\n    o(this, \"getTokenBridge\", () => this.getProtocol(\"TokenBridge\"));\n    /**\n     * Check to see if the Automatic Token Bridge protocol is supported by this chain\n     * @returns  a boolean indicating if this chain supports the Automatic Token Bridge protocol\n     */\n    o(this, \"supportsAutomaticTokenBridge\", () => this.supportsProtocol(\"AutomaticTokenBridge\"));\n    /**\n     * Get the Automatic Token Bridge protocol client for this chain\n     * @returns the Automatic Token Bridge protocol client for this chain\n     */\n    o(this, \"getAutomaticTokenBridge\", () => this.getProtocol(\"AutomaticTokenBridge\"));\n    /**\n     * Check to see if the Circle Bridge protocol is supported by this chain\n     * @returns a boolean indicating if this chain supports the Circle Bridge protocol\n     */\n    o(this, \"supportsCircleBridge\", () => this.supportsProtocol(\"CircleBridge\"));\n    /**\n     * Get the Circle Bridge protocol client for this chain\n     * @returns the Circle Bridge protocol client for this chain\n     */\n    o(this, \"getCircleBridge\", () => this.getProtocol(\"CircleBridge\"));\n    /**\n     * Check to see if the Automatic Circle Bridge protocol is supported by this chain\n     * @returns a boolean indicating if this chain supports the Automatic Circle Bridge protocol\n     */\n    o(this, \"supportsAutomaticCircleBridge\", () => this.supportsProtocol(\"AutomaticCircleBridge\"));\n    /**\n     * Get the Automatic Circle Bridge protocol client for this chain\n     * @returns the Automatic Circle Bridge protocol client for this chain\n     */\n    o(this, \"getAutomaticCircleBridge\", () => this.getProtocol(\"AutomaticCircleBridge\"));\n    /**\n     * Check to see if the IBC Bridge protocol is supported by this chain\n     * @returns a boolean indicating if this chain supports the IBC Bridge protocol\n     */\n    o(this, \"supportsIbcBridge\", () => this.supportsProtocol(\"IbcBridge\"));\n    /**\n     * Get the IBC Bridge protocol client for this chain\n     * @returns the IBC Bridge protocol client for this chain\n     */\n    o(this, \"getIbcBridge\", () => this.getProtocol(\"IbcBridge\"));\n    /**\n     * Check to see if the Portico Bridge protocol is supported by this chain\n     * @returns a boolean indicating if this chain supports the Portico Bridge protocol\n     */\n    o(this, \"supportsPorticoBridge\", () => this.supportsProtocol(\"PorticoBridge\"));\n    /**\n     * Get the Portico Bridge protocol client for this chain\n     * @returns the Portico Bridge protocol client for this chain\n     */\n    o(this, \"getPorticoBridge\", () => this.getProtocol(\"PorticoBridge\"));\n    /**\n     * Check to see if the TBTC Bridge protocol is supported by this chain\n     * @returns a boolean indicating if this chain supports the TBTC Bridge protocol\n     */\n    o(this, \"supportsTBTCBridge\", () => this.supportsProtocol(\"TBTCBridge\"));\n    /**\n     * Get the TBTC Bridge protocol client for this chain\n     * @returns the TBTC Bridge protocol client for this chain\n     */\n    o(this, \"getTBTCBridge\", () => this.getProtocol(\"TBTCBridge\"));\n    this.config = i.config[t], this.platform = i, this.chain = this.config.key, this.network = this.config.network, this.rpc = e;\n  }\n  /**\n   * Get an RPC connection for this chain, uses the configuration passed in\n   * the initial constructor\n   *\n   * @returns the RPC connection for this chain\n   */\n  getRpc() {\n    return this.rpc = this.rpc ? this.rpc : this.platform.getRpc(this.chain), this.rpc;\n  }\n  /**\n   *  Get the number of decimals for a token\n   *\n   *  @param token the token to get the decimals for\n   *  @returns the number of decimals for the token\n   */\n  async getDecimals(t) {\n    if (B(t))\n      return this.config.nativeTokenDecimals;\n    if (this.config.tokenMap) {\n      const i = m({ chain: this.chain, address: t }), e = w(this.network, this.chain, i);\n      if (e)\n        return e.decimals;\n    }\n    return this.platform.utils().getDecimals(this.chain, await this.getRpc(), t);\n  }\n  /**\n   * Get the balance of a token for a given address\n   *\n   * @param walletAddr the address to get the balance for\n   * @param token the token to get the balance for\n   * @returns the balance of the token for the address\n   *\n   */\n  async getBalance(t, i) {\n    return this.platform.utils().getBalance(this.chain, await this.getRpc(), t, i);\n  }\n  /**\n   * Get the latest block number seen by the chain according to the RPC\n   *\n   * @returns the latest block number\n   */\n  async getLatestBlock() {\n    return this.platform.utils().getLatestBlock(await this.getRpc());\n  }\n  /**\n   * Get the latest _finalized_ block number seen by the chain according to the RPC\n   *\n   * @returns the latest finalized block number\n   */\n  async getLatestFinalizedBlock() {\n    return this.platform.utils().getLatestFinalizedBlock(await this.getRpc());\n  }\n  /**\n   * Parse the Wormhole Core messages from a transaction\n   *\n   * @param txid the transaction to parse\n   * @returns the Wormhole Core messages emitted by the transaction\n   */\n  async parseTransaction(t) {\n    return this.platform.parseWormholeMessages(this.chain, await this.getRpc(), t);\n  }\n  /**\n   *  Send a transaction and wait for it to be confirmed\n   *\n   * @param stxns the signed transaction to send\n   * @returns the transaction hashes of the sent transactions\n   */\n  async sendWait(t) {\n    return this.platform.utils().sendWait(this.chain, await this.getRpc(), t);\n  }\n  /**\n   * Get the token data from the local cache if available\n   * @param symbol the symbol of the token to get\n   * @returns the token data if available\n   */\n  getToken(t) {\n    if (this.config.tokenMap && t in this.config.tokenMap)\n      return this.config.tokenMap[t];\n  }\n  /**\n   * Get the token id of the wrapped token for the native gas token\n   *\n   * @returns the wrapped token for the native gas token\n   */\n  async getNativeWrappedTokenId() {\n    if (this.config.wrappedNative) {\n      const { address: i } = this.config.wrappedNative;\n      return { chain: this.chain, address: P(this.chain, i) };\n    }\n    const t = await this.getTokenBridge();\n    return { chain: this.chain, address: await t.getWrappedNative() };\n  }\n  /**\n   * Get the token account for a given address and token\n   *\n   * @remarks\n   * This is really only useful in the context of Solana but in order\n   * to provide a consistent interface, we provide it here.\n   *\n   * @param address the address to get the token account for\n   * @param token the token to get the token account for\n   * @returns the token account for the address and token\n   */\n  async getTokenAccount(t, i) {\n    return { chain: this.chain, address: t };\n  }\n  /**\n   * Check to see if a given protocol is supported by this chain\n   * by checking if it is registered in the platform and the configuration\n   * is available and correct\n   *\n   * @param protocolName the name of the Protocol to check for support\n   * @returns a boolean indicating if this protocol is supported\n   */\n  supportsProtocol(t) {\n    return T(this.chain, t);\n  }\n  /**\n   * Construct a protocol client for the given protocol\n   *\n   * Note: If no contracts are passed, we assume the default contracts should be used\n   * and that the protocol client is cacheable\n   *\n   * @param protocolName The name of the protocol to construct a client for\n   * @returns An instance of the protocol client that implements the protocol interface for the chain\n   */\n  async getProtocol(t, i, e) {\n    if (!i && this.protocols.has(t))\n      return this.protocols.get(t);\n    const n = i ? { ...this.config.contracts, ...i } : this.config.contracts, a = e ?? await this.getRpc(), h = this.platform.getProtocolInitializer(t);\n    let c;\n    if (e) {\n      if (i)\n        throw new Error(\"Custom contracts are currently not supported with custom rpc connection. Add the contracts to the base config.\");\n      c = await this.platform.getProtocol(t, a);\n    } else if (k(h)) {\n      const p = await h.getVersion(a, n);\n      c = new h(this.network, this.chain, a, n, p);\n    } else\n      c = new h(this.network, this.chain, a, n);\n    return i || this.protocols.set(t, c), c;\n  }\n}\nexport {\n  I as C,\n  W as P,\n  R as r\n};\n"],"names":["g","Object","defineProperty","x","v","o","I","constructor","t","a","super","y","_platform","getRpc","this","config","network","f","MAINNET","TESTNET","n","w","fullnode","rpc","C","Error","getChain","nativeTokenId","isSupportedChain","concat","_","tokenId","h","isNativeTokenId","chain","b","getDecimals","u","T","e","toString","getFungibleAssetMetadataByAssetType","assetType","decimals","getBalance","r","i","_ref","getCurrentFungibleAssetBalances","options","where","owner_address","_eq","asset_type","amount","s","status","getBalances","sendWait","transaction","submit","simple","waitForTransaction","transactionHash","hash","push","getLatestBlock","getLedgerInfo","Number","block_height","getLatestFinalizedBlock","chainFromChainId","N","BigInt","chainFromRpc","chain_id","l","c","k","m","enumerable","configurable","writable","value","p","d","_chain","_account","_rpc","_debug","address","accountAddress","signAndSend","description","console","log","build","sender","data","_simSignSend","simulate","signerPublicKey","publicKey","then","forEach","success","vm_status","JSON","stringify","signAndSubmitTransaction","signer","P","Address","Platform","getSigner","async","fromPrivateKey","privateKey","decode","protocols","WormholeCore","TokenBridge","CircleBridge","A","R","W","utils","getProtocol","fromRpc","getProtocolInitializer","parseWormholeMessages","parseTransaction","Map","supportsProtocol","platform","key","B","nativeTokenDecimals","tokenMap","getToken","getNativeWrappedTokenId","wrappedNative","getTokenBridge","getWrappedNative","getTokenAccount","get","has","_objectSpread","contracts","getVersion","set"],"sourceRoot":""}