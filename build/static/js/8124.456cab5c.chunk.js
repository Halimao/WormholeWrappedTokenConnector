"use strict";(self.webpackChunkwormhole_connector=self.webpackChunkwormhole_connector||[]).push([[8124],{8080:(t,e,i)=>{i.d(e,{A:()=>u,S:()=>d,T:()=>l,a:()=>p,b:()=>c,i:()=>m});var o=i(9379),n=i(7547),r=i(9801),s=Object.defineProperty,a=(t,e,i)=>((t,e,i)=>e in t?s(t,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[e]=i)(t,"symbol"!=typeof e?e+"":e,i);class c extends r.C{async getTokenAccount(t,e){const{getAssociatedTokenAddress:o}=await i.e(8299).then(i.bind(i,8299)),r=new n.b1(e).unwrap(),s=new n.b1(t).unwrap(),a=await o(r,s);return{chain:this.chain,address:new n.b1(a.toString())}}}const l=new n.af("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),h=new n.af("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),u=new n.af("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");new n.af("So11111111111111111111111111111111111111112"),new n.af("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");const g=class t extends r.P{constructor(e,i){super(e,null!==i&&void 0!==i?i:(0,n.bE)(e,t._platform))}getRpc(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{commitment:"confirmed",disableRetryOnRateLimit:!0};if(t in this.config)return new n.ae(this.config[t].rpc,e);throw new Error("No configuration available for chain: "+t)}getChain(t,e){if(t in this.config)return new c(t,this,e);throw new Error("No configuration available for chain: "+t)}static nativeTokenId(e,i){if(!t.isSupportedChain(i))throw new Error("invalid chain: ".concat(i));return n.W.chainAddress(i,n.c7)}static isNativeTokenId(t,e,i){return!(!this.isSupportedChain(e)||i.chain!==e)&&this.nativeTokenId(t,e)==i}static isSupportedChain(e){return(0,n.a5)(e)===t._platform}static async getDecimals(e,i,o){if((0,n.j)(o))return(0,n.bG)(t._platform);let r=await i.getParsedAccountInfo(new n.b1(o).unwrap());if(!r||!r.value)throw new Error("could not fetch token details");const{decimals:s}=r.value.data.parsed.info;return s}static async getBalance(t,e,i,o){const r=new n.af(i);if((0,n.j)(o))return BigInt(await e.getBalance(r));const s=await e.getTokenAccountsByOwner(r,{mint:new n.b1(o).unwrap()}),a=s.value.length>0?s.value[0].pubkey:r,c=await e.getTokenAccountBalance(a);return BigInt(c.value.amount)}static async getBalances(t,e,i,o){let r;o.includes("native")&&(r=BigInt(await e.getBalance(new n.af(i))));const s=(await Promise.all([l,h].map(t=>new n.af(t)).map(t=>e.getParsedTokenAccountsByOwner(new n.af(i),{programId:t})))).reduce((t,e)=>t.concat(e.value),[]);return o.map(t=>{var e,i,o,a;if((0,n.j)(t))return{native:r};const c=new n.b1(t).toString(),l=null==(a=null==(o=null==(i=null==(e=s.find(e=>{var i,o;return(null==(o=null==(i=null==e?void 0:e.account.data.parsed)?void 0:i.info)?void 0:o.mint)===t.toString()}))?void 0:e.account.data.parsed)?void 0:i.info)?void 0:o.tokenAmount)?void 0:a.amount;return l?{[c]:BigInt(l)}:{[c]:null}}).reduce((t,e)=>Object.assign(t,e),{})}static async sendWait(t,e,i,o){const n=await Promise.all(i.map(t=>this.sendTxWithRetry(e,t,o))),r=n.map(t=>t.signature),s=n.filter(t=>t.response.value.err).map(t=>t.response.value.err);if(s.length>0)throw new Error("Failed to confirm transaction: ".concat(s));return r}static async sendTxWithRetry(t,e){var i;let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:5e3;const s=null!==(i=n.preflightCommitment)&&void 0!==i?i:t.commitment,a=await t.sendRawTransaction(e,(0,o.A)((0,o.A)({},n),{},{skipPreflight:!1,maxRetries:0,preflightCommitment:s})),{blockhash:c,lastValidBlockHeight:l}=await t.getLatestBlockhash(),h=t.confirmTransaction({signature:a,blockhash:c,lastValidBlockHeight:l},s);let u=null;for(;!u&&(u=await Promise.race([h,new Promise(t=>setTimeout(()=>{t(null)},r))]),!u);)await t.sendRawTransaction(e,(0,o.A)((0,o.A)({},n),{},{skipPreflight:!0,maxRetries:0,preflightCommitment:s}));return{signature:a,response:u}}static async latestBlock(t,e){return t.getLatestBlockhash(null!==e&&void 0!==e?e:t.commitment)}static async getLatestBlock(t){return await t.getSlot()}static async getLatestFinalizedBlock(t){const{lastValidBlockHeight:e}=await this.latestBlock(t,"finalized");return e}static chainFromChainId(e){const i=(0,n.bH)(t._platform,e);if(!i)throw new Error("No matching genesis hash to determine network and chain: ".concat(e));const[o,r]=i;return[o,r]}static async chainFromRpc(e){try{const i=await e.getGenesisHash();return t.chainFromChainId(i)}catch(i){if(e.rpcEndpoint.includes("http://127")||e.rpcEndpoint.includes("http://localhost")||"http://solana-devnet:8899"===e.rpcEndpoint)return["Devnet","Solana"];throw i}}};a(g,"_platform",n.b3);let p=g;class d{constructor(t,e,i,o){let n=arguments.length>4&&void 0!==arguments[4]&&arguments[4];a(this,"transaction"),a(this,"network"),a(this,"chain"),a(this,"description"),a(this,"parallelizable"),this.transaction=t,this.network=e,this.chain=i,this.description=o,this.parallelizable=n}}function m(t){return void 0!==t.signatures&&void 0!==t.message}},8124:(t,e,i)=>{i.d(e,{a:()=>v,d:()=>k,g:()=>g});var o=i(7547),n=i(8080),r=Object.defineProperty,s=(t,e,i)=>((t,e,i)=>e in t?r(t,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[e]=i)(t,"symbol"!=typeof e?e+"":e,i);const a=.5,c=1,l=1,h=1e8,u=5;async function g(t,e,i){var r,s,a;const[c,l]=await n.a.chainFromRpc(t),h="string"==typeof e?o.ap.fromSecretKey(o.c4.decode(e)):e;if(null!=i&&i.priorityFee&&i.priorityFee.percentile&&i.priorityFee.percentile>1)throw new Error("priorityFeePercentile must be a number between 0 and 1");return new p(t,l,h,null!==(r=null==i?void 0:i.debug)&&void 0!==r&&r,null!==(s=null==i?void 0:i.priorityFee)&&void 0!==s?s:{},null!==(a=null==i?void 0:i.retries)&&void 0!==a?a:u,null==i?void 0:i.sendOpts)}class p{constructor(t,e,i){var o;let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4?arguments[4]:void 0,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:u,c=arguments.length>6?arguments[6]:void 0;s(this,"_rpc"),s(this,"_chain"),s(this,"_keypair"),s(this,"_debug"),s(this,"_priorityFee"),s(this,"_maxResubmits"),s(this,"_sendOpts"),this._rpc=t,this._chain=e,this._keypair=i,this._debug=n,this._priorityFee=r,this._maxResubmits=a,this._sendOpts=c,this._sendOpts=null!==(o=this._sendOpts)&&void 0!==o?o:{preflightCommitment:this._rpc.commitment}}chain(){return this._chain}address(){return this._keypair.publicKey.toBase58()}retryable(t){var e;if(t instanceof o.c5)return!0;if(!(t instanceof o.c6)||!t.message.includes("Transaction simulation failed"))return!1;if(t.message.includes("Blockhash not found"))return!0;const i=null==(e=t.logs)?void 0:e.find(t=>t.startsWith("Program log: Error: "));return!!i&&!(!i.includes("Not enough bytes")&&!i.includes("Unexpected length of input"))}async signAndSend(t){var e;let{blockhash:i,lastValidBlockHeight:r}=await n.a.latestBlock(this._rpc);const s=[];for(const l of t){const{description:t,transaction:{transaction:a,signers:h}}=l;let u;this._debug&&console.log("Signing: ".concat(t," for ").concat(this.address())),null!=(e=this._priorityFee)&&e.percentile&&this._priorityFee.percentile>0&&(u=await m(this._rpc,a,this._priorityFee.percentile,this._priorityFee.percentileMultiple,this._priorityFee.min,this._priorityFee.max)),this._debug&&d(a);for(let e=0;e<this._maxResubmits;e++)try{if((0,n.i)(a)){if(u&&0===e){const t=o.aZ.decompile(a.message);t.instructions.push(...u),a.message=t.compileToV0Message()}a.message.recentBlockhash=i,a.sign([this._keypair,...null!==h&&void 0!==h?h:[]])}else u&&0===e&&a.add(...u),a.recentBlockhash=i,a.lastValidBlockHeight=r,a.partialSign(this._keypair,...null!==h&&void 0!==h?h:[]);this._debug&&console.log("Submitting transactions ");const{signature:t}=await n.a.sendTxWithRetry(this._rpc,a.serialize(),this._sendOpts);s.push(t);break}catch(c){if(e===this._maxResubmits-1||!this.retryable(c))throw c;this._debug&&console.log("Failed to send transaction on attempt ".concat(e,", retrying: "),c);const{blockhash:t,lastValidBlockHeight:o}=await n.a.latestBlock(this._rpc);r=o,i=t}}this._debug&&console.log("Waiting for confirmation for: ",s);const a=(await Promise.all(s.map(async t=>{try{return await this._rpc.confirmTransaction({signature:t,blockhash:i,lastValidBlockHeight:r},this._rpc.commitment)}catch(e){throw console.error("Failed to confirm transaction: ",e),e}}))).filter(t=>t.value.err).map(t=>t.value.err);if(a.length>0)throw new Error("Failed to confirm transaction: ".concat(a));return s}}function d(t){if((0,n.i)(t)){console.log(t.signatures);const e=t.message,i=e.getAccountKeys();e.compiledInstructions.forEach(t=>{console.log("Program",i.get(t.programIdIndex).toBase58()),console.log("Data: ",o.a3.encode(t.data)),console.log("Keys: ",t.accountKeyIndexes.map(t=>[t,i.get(t).toBase58()]))})}else console.log(t.signatures),console.log(t.feePayer),t.instructions.forEach(t=>{console.log("Program",t.programId.toBase58()),console.log("Data: ",t.data.toString("hex")),console.log("Keys: ",t.keys.map(t=>[t,t.pubkey.toBase58()]))})}async function m(t,e){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:a,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:c,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:l,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:h;const[u,g]=await Promise.all([f(t,e),v(t,e,i,n,r,s)]);return[o.an.setComputeUnitLimit({units:u}),o.an.setComputeUnitPrice({microLamports:g})]}async function f(t,e){var i;let o=25e4;try{const r=await((0,n.i)(e),t.simulateTransaction(e));r.value.err&&console.error("Error simulating Solana transaction: ".concat(r.value.err)),null!=(i=null==r?void 0:r.value)&&i.unitsConsumed&&(o=Math.round(1.2*r.value.unitsConsumed))}catch(r){console.error("Failed to calculate compute unit limit for Solana transaction: ".concat(r))}return o}async function w(t,e){if((0,n.i)(e)){const i=(await Promise.all(e.message.addressTableLookups.map(e=>t.getAddressLookupTable(e.accountKey)))).map(t=>t.value).filter(t=>null!==t),o=e.message,n=o.getAccountKeys({addressLookupTableAccounts:null!==i&&void 0!==i?i:void 0});return o.compiledInstructions.flatMap(t=>t.accountKeyIndexes).map(t=>o.isAccountWritable(t)?n.get(t):null).filter(Boolean)}return e.instructions.flatMap(t=>t.keys).map(t=>t.isWritable?t.pubkey:null).filter(Boolean)}async function v(t,e){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:a,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:c,n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:l,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:h,s=n;const u=await w(t,e);try{const e=await t.getRecentPrioritizationFees({lockedWritableAccounts:u});if(e){const t=e.map(t=>t.prioritizationFee).sort((t,e)=>t-e),n=Math.ceil(t.length*i);if(t.length>n){let e=t[n];o>0&&(e*=o),s=Math.max(s,e)}}}catch(g){console.error("Error fetching Solana recent fees",g)}return Math.min(Math.max(s,n),r)}async function k(t,e){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:c,n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:l,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:h;const s=1e4*(arguments.length>2&&void 0!==arguments[2]?arguments[2]:a);if(s<1||s>1e4)throw new Error("percentile must be between 0.0001 and 1");const u=t._rpcRequest,g=[await w(t,e),{percentile:s}],p=await u("getRecentPrioritizationFees",g);if(p.error)throw new Error(p.error);const d=p.result.map(t=>t.prioritizationFee);if(0===d.length)return n;const m=Math.floor((0,o.c2)(d)*(i>0?i:1));return(0,o.c3)(m,n,r)}},9801:(t,e,i)=>{i.d(e,{C:()=>u,P:()=>h,r:()=>c});var o=i(9379),n=i(7547),r=Object.defineProperty,s=(t,e,i)=>((t,e,i)=>e in t?r(t,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[e]=i)(t,"symbol"!=typeof e?e+"":e,i);const a={};function c(t,e,i){e in a||(a[e]={});if(t in a[e])throw new Error("Protocol ".concat(t," for protocol ").concat(e," has already registered"));a[e][t]=i}function l(t,e){if(e in a){const i=a[e];if(i&&t in i){const e=i[t];if(e)return e}}throw new Error("No protocols registered for ".concat(t,":").concat(e,". This may be because the platform specific protocol implementation is not registered (by installing and importing it) or no implementation exists for this platform"))}class h{constructor(t,e){s(this,"network"),s(this,"config"),this.network=t,this.config=e}utils(){return this.constructor}getProtocol(t,e){return((t,e,i,o)=>l(t,e).fromRpc(i,o))(this.utils()._platform,t,e,this.config)}getProtocolInitializer(t){return l(this.utils()._platform,t)}async parseWormholeMessages(t,e,i){return(await this.getProtocol("WormholeCore",e)).parseTransaction(i)}}class u{constructor(t,e,i){s(this,"network"),s(this,"chain"),s(this,"config"),s(this,"platform"),s(this,"rpc"),s(this,"protocols",new Map),s(this,"supportsWormholeCore",()=>this.supportsProtocol("WormholeCore")),s(this,"getWormholeCore",()=>this.getProtocol("WormholeCore")),s(this,"supportsTokenBridge",()=>this.supportsProtocol("TokenBridge")),s(this,"getTokenBridge",()=>this.getProtocol("TokenBridge")),s(this,"supportsAutomaticTokenBridge",()=>this.supportsProtocol("AutomaticTokenBridge")),s(this,"getAutomaticTokenBridge",()=>this.getProtocol("AutomaticTokenBridge")),s(this,"supportsCircleBridge",()=>this.supportsProtocol("CircleBridge")),s(this,"getCircleBridge",()=>this.getProtocol("CircleBridge")),s(this,"supportsAutomaticCircleBridge",()=>this.supportsProtocol("AutomaticCircleBridge")),s(this,"getAutomaticCircleBridge",()=>this.getProtocol("AutomaticCircleBridge")),s(this,"supportsIbcBridge",()=>this.supportsProtocol("IbcBridge")),s(this,"getIbcBridge",()=>this.getProtocol("IbcBridge")),s(this,"supportsPorticoBridge",()=>this.supportsProtocol("PorticoBridge")),s(this,"getPorticoBridge",()=>this.getProtocol("PorticoBridge")),s(this,"supportsTBTCBridge",()=>this.supportsProtocol("TBTCBridge")),s(this,"getTBTCBridge",()=>this.getProtocol("TBTCBridge")),this.config=e.config[t],this.platform=e,this.chain=this.config.key,this.network=this.config.network,this.rpc=i}getRpc(){return this.rpc=this.rpc?this.rpc:this.platform.getRpc(this.chain),this.rpc}async getDecimals(t){if((0,n.j)(t))return this.config.nativeTokenDecimals;if(this.config.tokenMap){const e=(0,n.q)({chain:this.chain,address:t}),i=(0,n.c8)(this.network,this.chain,e);if(i)return i.decimals}return this.platform.utils().getDecimals(this.chain,await this.getRpc(),t)}async getBalance(t,e){return this.platform.utils().getBalance(this.chain,await this.getRpc(),t,e)}async getLatestBlock(){return this.platform.utils().getLatestBlock(await this.getRpc())}async getLatestFinalizedBlock(){return this.platform.utils().getLatestFinalizedBlock(await this.getRpc())}async parseTransaction(t){return this.platform.parseWormholeMessages(this.chain,await this.getRpc(),t)}async sendWait(t){return this.platform.utils().sendWait(this.chain,await this.getRpc(),t)}getToken(t){if(this.config.tokenMap&&t in this.config.tokenMap)return this.config.tokenMap[t]}async getNativeWrappedTokenId(){if(this.config.wrappedNative){const{address:t}=this.config.wrappedNative;return{chain:this.chain,address:(0,n.a7)(this.chain,t)}}const t=await this.getTokenBridge();return{chain:this.chain,address:await t.getWrappedNative()}}async getTokenAccount(t,e){return{chain:this.chain,address:t}}supportsProtocol(t){return function(t,e){const i=(0,n.a6)(t)?n.a5.get(t):t;return e in a&&i in a[e]}(this.chain,t)}async getProtocol(t,e,i){if(!e&&this.protocols.has(t))return this.protocols.get(t);const n=e?(0,o.A)((0,o.A)({},this.config.contracts),e):this.config.contracts,r=null!==i&&void 0!==i?i:await this.getRpc(),s=this.platform.getProtocolInitializer(t);let a;if(i){if(e)throw new Error("Custom contracts are currently not supported with custom rpc connection. Add the contracts to the base config.");a=await this.platform.getProtocol(t,r)}else if("getVersion"in s){const t=await s.getVersion(r,n);a=new s(this.network,this.chain,r,n,t)}else a=new s(this.network,this.chain,r,n);return e||this.protocols.set(t,a),a}}}}]);
//# sourceMappingURL=8124.456cab5c.chunk.js.map