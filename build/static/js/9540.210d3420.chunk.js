"use strict";(self.webpackChunkwormhole_connector=self.webpackChunkwormhole_connector||[]).push([[9540],{9540:(e,a,t)=>{t.d(a,{offchainLookup:()=>u,offchainLookupSignature:()=>l});var s=t(1487),r=t(6630);class n extends r.B{constructor(e){let{callbackSelector:a,cause:t,data:s,extraData:n,sender:o,urls:c}=e;var l;super(t.shortMessage||"An error occurred while fetching for an offchain result.",{cause:t,metaMessages:[...t.metaMessages||[],null!=(l=t.metaMessages)&&l.length?"":[],"Offchain Gateway Call:",c&&["  Gateway URL(s):",...c.map(e=>"    ".concat((0,r.ai)(e)))],"  Sender: ".concat(o),"  Data: ".concat(s),"  Callback selector: ".concat(a),"  Extra data: ".concat(n)].flat(),name:"OffchainLookupError"})}}class o extends r.B{constructor(e){let{result:a,url:t}=e;super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:["Gateway URL: ".concat((0,r.ai)(t)),"Response: ".concat((0,r.o)(a))],name:"OffchainLookupResponseMalformedError"})}}class c extends r.B{constructor(e){let{sender:a,to:t}=e;super("Reverted sender address does not match target contract address (`to`).",{metaMessages:["Contract address: ".concat(t),"OffchainLookup sender address: ".concat(a)],name:"OffchainLookupSenderMismatchError"})}}const l="0x556f1830",d={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function u(e,a){let{blockNumber:t,blockTag:r,data:o,to:l}=a;const{args:u}=(0,s.d)({data:o,abi:[d]}),[f,p,h,y,m]=u,{ccipRead:w}=e,b=w&&"function"==typeof(null==w?void 0:w.request)?w.request:i;try{if(!(0,s.i)(l,f))throw new c({sender:f,to:l});const a=p.includes(s.l)?await(0,s.a)({data:h,ccipRequest:b}):await b({data:h,sender:f,urls:p}),{data:n}=await(0,s.b)(e,{blockNumber:t,blockTag:r,data:(0,s.e)([y,(0,s.f)([{type:"bytes"},{type:"bytes"}],[a,m])]),to:l});return n}catch(k){throw new n({callbackSelector:y,cause:k,data:o,extraData:m,sender:f,urls:p})}}async function i(e){let{data:a,sender:t,urls:s}=e;var n;let c=new Error("An unknown error occurred.");for(let d=0;d<s.length;d++){const e=s[d],u=e.includes("{data}")?"GET":"POST",i="POST"===u?{data:a,sender:t}:void 0,f="POST"===u?{"Content-Type":"application/json"}:{};try{const s=await fetch(e.replace("{sender}",t.toLowerCase()).replace("{data}",a),{body:JSON.stringify(i),headers:f,method:u});let l;if(l=null!=(n=s.headers.get("Content-Type"))&&n.startsWith("application/json")?(await s.json()).data:await s.text(),!s.ok){c=new r.aj({body:i,details:null!=l&&l.error?(0,r.o)(l.error):s.statusText,headers:s.headers,status:s.status,url:e});continue}if(!(0,r.i)(l)){c=new o({result:l,url:e});continue}return l}catch(l){c=new r.aj({body:i,details:l.message,url:e})}}throw c}}}]);
//# sourceMappingURL=9540.210d3420.chunk.js.map