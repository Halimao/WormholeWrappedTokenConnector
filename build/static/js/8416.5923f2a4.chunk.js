"use strict";(self.webpackChunkwormhole_connector=self.webpackChunkwormhole_connector||[]).push([[8416],{3332:(t,i,e)=>{e.d(i,{A:()=>p,a:()=>c});var o=e(6045),r=e(7547),s=e(9801),n=e(6568),a=Object.defineProperty;class c extends s.C{}const h=class t extends s.P{constructor(i,e){super(i,null!==e&&void 0!==e?e:(0,r.bE)(i,t._platform))}getRpc(t){if(t in this.config){const i="Mainnet"===this.network?o.e.MAINNET:o.e.TESTNET,e=new o.u({fullnode:this.config[t].rpc,network:i});return new o.W(e)}throw new Error("No configuration available for chain: "+t)}getChain(t,i){if(t in this.config)return new c(t,this);throw new Error("No configuration available for chain: "+t)}static nativeTokenId(t,i){if(!this.isSupportedChain(i))throw new Error("invalid chain: ".concat(i));return r.W.tokenId(i,n.a)}static isNativeTokenId(t,i,e){return!(!this.isSupportedChain(i)||e.chain!==i)&&this.nativeTokenId(t,i)==e}static isSupportedChain(i){return(0,r.a5)(i)===t._platform}static async getDecimals(i,e,o){if((0,r.j)(o)||o===n.a)return(0,r.bG)(t._platform);const s=o.toString();return(await e.getFungibleAssetMetadataByAssetType({assetType:s})).decimals}static async getBalance(t,i,e,o){var s;const a=(0,r.j)(o)?n.a:o.toString();try{var c;return null!==(c=null==(s=(await i.getCurrentFungibleAssetBalances({options:{where:{owner_address:{_eq:e},asset_type:{_eq:a}}}}))[0])?void 0:s.amount)&&void 0!==c?c:null}catch(h){if(404===h.status)return null;throw h}}static async getBalances(t,i,e,o){try{const t=await i.getCurrentFungibleAssetBalances({options:{where:{owner_address:{_eq:e}}}});let o={};for(const i of t)if(i.asset_type){o["0x1::aptos_coin::AptosCoin"===i.asset_type?"native":i.asset_type]=i.amount}return o}catch(r){if(404===r.status)return{};throw r}}static async sendWait(t,i,e){const o=[];for(const r of e){const t=await i.transaction.submit.simple(r.transaction),e=await i.waitForTransaction({transactionHash:t.hash});o.push(e.hash)}return o}static async getLatestBlock(t){const i=await t.getLedgerInfo();return Number(i.block_height)}static async getLatestFinalizedBlock(t){const i=await t.getLedgerInfo();return Number(i.block_height)}static chainFromChainId(i){const e=(0,r.bH)(t._platform,BigInt(i));if(!e)throw new Error("No matching chainId to determine network and chain: ".concat(i));const[o,s]=e;return[o,s]}static async chainFromRpc(t){const i=await t.getLedgerInfo();return this.chainFromChainId(i.chain_id.toString())}};var l,g,u;l=h,g="_platform",u=n._,((t,i,e)=>{i in t?a(t,i,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[i]=e})(l,"symbol"!=typeof g?g+"":g,u);let p=h},8416:(t,i,e)=>{e.r(i),e.d(i,{default:()=>l});var o=e(3332),r=e(6045),s=e(7547),n=e(6568),a=Object.defineProperty,c=(t,i,e)=>((t,i,e)=>i in t?a(t,i,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[i]=e)(t,"symbol"!=typeof i?i+"":i,e);class h{constructor(t,i,e,o){c(this,"_chain"),c(this,"_account"),c(this,"_rpc"),c(this,"_debug"),this._chain=t,this._account=i,this._rpc=e,this._debug=o}chain(){return this._chain}address(){return this._account.accountAddress.toString()}async signAndSend(t){const i=[];for(const e of t){const{description:t,transaction:o}=e;this._debug&&console.log("Signing: ".concat(t," for ").concat(this.address()));const r=await this._rpc.transaction.build.simple({sender:this._account.accountAddress,data:o}),{hash:s}=await this._simSignSend(r);i.push(s)}return i}async _simSignSend(t){return await this._rpc.transaction.simulate.simple({signerPublicKey:this._account.publicKey,transaction:t}).then(t=>t.forEach(t=>{if(!t.success)throw new Error("Transaction failed: ".concat(t.vm_status,"\n").concat(JSON.stringify(t,null,2)))})),this._rpc.signAndSubmitTransaction({signer:this._account,transaction:t}).then(t=>this._rpc.waitForTransaction({transactionHash:t.hash}))}}const l={Address:n.A,Platform:o.A,getSigner:async function(t,i){const[e,n]=await o.A.chainFromRpc(t),a=r.z.fromPrivateKey({privateKey:new r.a(s.a3.decode(i))});return new h(n,a,t)},protocols:{WormholeCore:()=>e.e(2447).then(e.bind(e,2447)),TokenBridge:()=>e.e(5701).then(e.bind(e,5701)),CircleBridge:()=>e.e(5878).then(e.bind(e,5878))},getChain:(t,i,e)=>new o.a(i,new o.A(t,(0,s.bD)(t,n._,{[i]:e})))}},9801:(t,i,e)=>{e.d(i,{C:()=>g,P:()=>l,r:()=>c});var o=e(9379),r=e(7547),s=Object.defineProperty,n=(t,i,e)=>((t,i,e)=>i in t?s(t,i,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[i]=e)(t,"symbol"!=typeof i?i+"":i,e);const a={};function c(t,i,e){i in a||(a[i]={});if(t in a[i])throw new Error("Protocol ".concat(t," for protocol ").concat(i," has already registered"));a[i][t]=e}function h(t,i){if(i in a){const e=a[i];if(e&&t in e){const i=e[t];if(i)return i}}throw new Error("No protocols registered for ".concat(t,":").concat(i,". This may be because the platform specific protocol implementation is not registered (by installing and importing it) or no implementation exists for this platform"))}class l{constructor(t,i){n(this,"network"),n(this,"config"),this.network=t,this.config=i}utils(){return this.constructor}getProtocol(t,i){return((t,i,e,o)=>h(t,i).fromRpc(e,o))(this.utils()._platform,t,i,this.config)}getProtocolInitializer(t){return h(this.utils()._platform,t)}async parseWormholeMessages(t,i,e){return(await this.getProtocol("WormholeCore",i)).parseTransaction(e)}}class g{constructor(t,i,e){n(this,"network"),n(this,"chain"),n(this,"config"),n(this,"platform"),n(this,"rpc"),n(this,"protocols",new Map),n(this,"supportsWormholeCore",()=>this.supportsProtocol("WormholeCore")),n(this,"getWormholeCore",()=>this.getProtocol("WormholeCore")),n(this,"supportsTokenBridge",()=>this.supportsProtocol("TokenBridge")),n(this,"getTokenBridge",()=>this.getProtocol("TokenBridge")),n(this,"supportsAutomaticTokenBridge",()=>this.supportsProtocol("AutomaticTokenBridge")),n(this,"getAutomaticTokenBridge",()=>this.getProtocol("AutomaticTokenBridge")),n(this,"supportsCircleBridge",()=>this.supportsProtocol("CircleBridge")),n(this,"getCircleBridge",()=>this.getProtocol("CircleBridge")),n(this,"supportsAutomaticCircleBridge",()=>this.supportsProtocol("AutomaticCircleBridge")),n(this,"getAutomaticCircleBridge",()=>this.getProtocol("AutomaticCircleBridge")),n(this,"supportsIbcBridge",()=>this.supportsProtocol("IbcBridge")),n(this,"getIbcBridge",()=>this.getProtocol("IbcBridge")),n(this,"supportsPorticoBridge",()=>this.supportsProtocol("PorticoBridge")),n(this,"getPorticoBridge",()=>this.getProtocol("PorticoBridge")),n(this,"supportsTBTCBridge",()=>this.supportsProtocol("TBTCBridge")),n(this,"getTBTCBridge",()=>this.getProtocol("TBTCBridge")),this.config=i.config[t],this.platform=i,this.chain=this.config.key,this.network=this.config.network,this.rpc=e}getRpc(){return this.rpc=this.rpc?this.rpc:this.platform.getRpc(this.chain),this.rpc}async getDecimals(t){if((0,r.j)(t))return this.config.nativeTokenDecimals;if(this.config.tokenMap){const i=(0,r.q)({chain:this.chain,address:t}),e=(0,r.c8)(this.network,this.chain,i);if(e)return e.decimals}return this.platform.utils().getDecimals(this.chain,await this.getRpc(),t)}async getBalance(t,i){return this.platform.utils().getBalance(this.chain,await this.getRpc(),t,i)}async getLatestBlock(){return this.platform.utils().getLatestBlock(await this.getRpc())}async getLatestFinalizedBlock(){return this.platform.utils().getLatestFinalizedBlock(await this.getRpc())}async parseTransaction(t){return this.platform.parseWormholeMessages(this.chain,await this.getRpc(),t)}async sendWait(t){return this.platform.utils().sendWait(this.chain,await this.getRpc(),t)}getToken(t){if(this.config.tokenMap&&t in this.config.tokenMap)return this.config.tokenMap[t]}async getNativeWrappedTokenId(){if(this.config.wrappedNative){const{address:t}=this.config.wrappedNative;return{chain:this.chain,address:(0,r.a7)(this.chain,t)}}const t=await this.getTokenBridge();return{chain:this.chain,address:await t.getWrappedNative()}}async getTokenAccount(t,i){return{chain:this.chain,address:t}}supportsProtocol(t){return function(t,i){const e=(0,r.a6)(t)?r.a5.get(t):t;return i in a&&e in a[i]}(this.chain,t)}async getProtocol(t,i,e){if(!i&&this.protocols.has(t))return this.protocols.get(t);const r=i?(0,o.A)((0,o.A)({},this.config.contracts),i):this.config.contracts,s=null!==e&&void 0!==e?e:await this.getRpc(),n=this.platform.getProtocolInitializer(t);let a;if(e){if(i)throw new Error("Custom contracts are currently not supported with custom rpc connection. Add the contracts to the base config.");a=await this.platform.getProtocol(t,s)}else if("getVersion"in n){const t=await n.getVersion(s,r);a=new n(this.network,this.chain,s,r,t)}else a=new n(this.network,this.chain,s,r);return i||this.protocols.set(t,a),a}}}}]);
//# sourceMappingURL=8416.5923f2a4.chunk.js.map