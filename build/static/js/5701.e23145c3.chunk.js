"use strict";(self.webpackChunkwormhole_connector=self.webpackChunkwormhole_connector||[]).push([[5701],{2126:(e,t,n)=>{n.d(t,{A:()=>a});var r=Object.defineProperty,s=(e,t,n)=>((e,t,n)=>t in e?r(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n)(e,"symbol"!=typeof t?t+"":t,n);class a{constructor(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];s(this,"transaction"),s(this,"network"),s(this,"chain"),s(this,"description"),s(this,"parallelizable"),this.transaction=e,this.network=t,this.chain=n,this.description=r,this.parallelizable=a}}},5701:(e,t,n)=>{n.r(t),n.d(t,{AptosTokenBridge:()=>g});var r=n(9379),s=n(6218),a=n(600),i=n(7547),o=n(6568),d=n(3332),c=n(2126),h=n(9801),u=Object.defineProperty,l=(e,t,n)=>((e,t,n)=>t in e?u(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n)(e,"symbol"!=typeof t?t+"":t,n);const A=[(0,r.A)({name:"tokenBridgeAddress"},i.aJ),(0,r.A)({name:"chain"},(0,i.aL)()),{name:"domainSeparator",binary:"bytes",custom:i.$.encode(o.b),omit:!0},(0,r.A)({name:"tokenId"},i.aJ),{name:"domainSeparator",binary:"bytes",custom:new Uint8Array([255]),omit:!0}];class g{constructor(e,t,n,r){l(this,"network"),l(this,"chain"),l(this,"connection"),l(this,"contracts"),l(this,"chainId"),l(this,"tokenBridgeAddress"),this.network=e,this.chain=t,this.connection=n,this.contracts=r,this.chainId=(0,i.aP)(t);const s=r.tokenBridge;if(!s)throw new Error("TokenBridge contract Address for chain ".concat(t," not found"));this.tokenBridgeAddress=s}static async fromRpc(e,t){const[n,r]=await d.A.chainFromRpc(e),s=t[r];if(s.network!==n)throw new Error("Network mismatch "+s.network+" !== "+n);return new g(n,r,e,s.contracts)}async isWrappedAsset(e){try{return await this.getOriginalAsset(e),!0}catch(t){return!1}}async getOriginalAsset(e){const t=e.toString().split(o.b),n=await this.connection.getAccountResource({accountAddress:t[0],resourceType:"".concat(this.tokenBridgeAddress,"::state::OriginInfo")});if(!n)throw(0,i.d9)(e.toString());return{chain:(0,i.aB)(parseInt(n.token_chain.number)),address:new i._(n.token_address.external_address)}}async getTokenUniversalAddress(e){return new i._(i.a3.encode((0,i.cv)(e.toString()),!0))}async getTokenNativeAddress(e,t){const n=e===this.chain?await this.getTypeFromExternalAddress(t.toString()):await this.getAssetFullyQualifiedType({chain:e,address:t});if(!n)throw new Error("Invalid asset address.");return new o.A(n)}async hasWrappedAsset(e){try{return await this.getWrappedAsset(e),!0}catch(t){}return!1}async getWrappedAsset(e){if((0,i.j)(e.address))throw new Error("native asset cannot be a wrapped asset");const t=await this.getAssetFullyQualifiedType(e);if(!t)throw new Error("Invalid asset address.");return await this.connection.getAccountResource({accountAddress:(0,o.c)(t),resourceType:"".concat(this.tokenBridgeAddress,"::state::OriginInfo")}),(0,i.a7)(this.chain,t)}async isTransferCompleted(e){const t=(await this.connection.getAccountResource({accountAddress:this.tokenBridgeAddress,resourceType:"".concat(this.tokenBridgeAddress,"::state::State")})).consumed_vaas.elems.handle;try{return await this.connection.getTableItem({handle:t,data:{key_type:"vector<u8>",value_type:"u8",key:"0x".concat(i.d.Buffer.from((0,i.aO)(e.hash)).toString("hex"))}}),!0}catch(n){return!1}}async getWrappedNative(){return(0,i.a7)(this.chain,o.a)}createAttestation(e,t){var n=this;return(0,a.A)(function*(){const t={chain:n.chain,address:new o.A(e)},r=yield(0,s.A)(n.getAssetFullyQualifiedType(t));if(!r)throw new Error("Invalid asset address.");yield n.createUnsignedTx({function:"".concat(n.tokenBridgeAddress,"::attest_token::attest_token_entry"),typeArguments:[r],functionArguments:[]},"Aptos.AttestToken")})()}submitAttestation(e,t){var n=this;return(0,a.A)(function*(){yield n.createUnsignedTx({function:"".concat(n.tokenBridgeAddress,"::wrapped::create_wrapped_coin_type"),typeArguments:[],functionArguments:[(0,i.L)(e)]},"Aptos.CreateWrappedCoinType");const t=yield(0,s.A)(n.getAssetFullyQualifiedType(e.payload.token));if(!t)throw new Error("Invalid asset address.");yield n.createUnsignedTx({function:"".concat(n.tokenBridgeAddress,"::wrapped::create_wrapped_coin"),typeArguments:[t],functionArguments:[(0,i.L)(e)]},"Aptos.CreateWrappedCoin")})()}transfer(e,t,n,r,s){var d=this;return(0,a.A)(function*(){const e=(0,i.j)(n)?o.a:n.toString(),a=t.address.toUniversalAddress().toUint8Array(),c=(0,i.aP)(t.chain);s?yield d.createUnsignedTx({function:"".concat(d.tokenBridgeAddress,"::transfer_tokens::transfer_tokens_with_payload_entry"),typeArguments:[e],functionArguments:[r,c,a,0n,s]},"Aptos.TransferTokensWithPayload"):yield d.createUnsignedTx({function:"".concat(d.tokenBridgeAddress,"::transfer_tokens::transfer_tokens_entry"),typeArguments:[e],functionArguments:[r,c,a,0n,0n]},"Aptos.TransferTokens")})()}redeem(e,t){var n=this;return(0,a.A)(function(e,t){return function*(){const e=t.payload.token.chain===n.chain?yield(0,s.A)(n.getTypeFromExternalAddress(t.payload.token.address.toString())):yield(0,s.A)(n.getAssetFullyQualifiedType(t.payload.token));if(!e)throw new Error("Invalid asset address.");yield n.createUnsignedTx({function:"".concat(n.tokenBridgeAddress,"::complete_transfer::submit_vaa_and_register_entry"),typeArguments:[e],functionArguments:[(0,i.L)(t)]},"Aptos.CompleteTransfer")}()}).apply(this,arguments)}async getAssetFullyQualifiedType(e){return e.chain===this.chain?(0,o.i)(e.address.toString())?e.address.toString():null:"".concat(g.getForeignAssetAddress(this.chain,this.tokenBridgeAddress,e),"::coin::T")}async getTypeFromExternalAddress(e){try{const t=await this.connection.getAccountResource({accountAddress:this.tokenBridgeAddress,resourceType:"".concat(this.tokenBridgeAddress,"::state::State")}),{handle:n}=t.native_infos,r=await this.connection.getTableItem({handle:n,data:{key_type:"".concat(this.tokenBridgeAddress,"::token_hash::TokenHash"),value_type:"0x1::type_info::TypeInfo",key:{hash:e}}});return r?[r.account_address,String.fromCharCode(...i.a3.decode(r.module_name)),String.fromCharCode(...i.a3.decode(r.struct_name))].join(o.b):null}catch(t){return null}}static getForeignAssetAddress(e,t,n){if((0,i.j)(n.address))throw new Error("Invalid token address");const r=(s={chain:n.chain,tokenBridgeAddress:new o.A(t).toUniversalAddress(),tokenId:n.address.toUniversalAddress()},(0,i.aN)(A,s));var s;return i.a3.encode((0,i.cv)(r),!0)}createUnsignedTx(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return new c.A(e,this.network,this.chain,t,n)}}(0,h.r)("Aptos","TokenBridge",g)}}]);
//# sourceMappingURL=5701.e23145c3.chunk.js.map